Exercise 1.1
 Bookmark this page
In this exercise, you will containerize a sample application by building two containers: one for the front end and another for the app server. The application is a simple Python web app that displays the current time at different locations. You will build the containers using Docker. By the end of this exercise, you will have a containerized application running on your AWS Cloud9 instance.

Like you did in the last two courses, edX Developer: Building on AWS and edX Developer: Deploying on AWS, you will create an AWS Identity and Access Management (IAM) user specifically for this course. This IAM user will have limited access to the AWS resources required by this project. As a best practice, make sure to use the username and password of the IAM user you create in this exercise (rather than your root credentials) to sign in to the AWS Management Console.

To begin, follow the steps below.
1. Create an IAM policy.
In this section, you will create an IAM customer-managed policy. Customer-managed policies provide more precise control over your policies than AWS managed policies. This policy will have permissions specific to the AWS resources you need for this course.

In the AWS Management Console, click Services, then click IAM to open the IAM dashboard.
In the left navigation menu, click Policies.
Click Create policy.
Click the JSON tab.
In the editor textbox, completely replace the sample policy with the following.
   {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "rds:*",
                "ssm:*",
                "kms:*",
                "apigateway:*",
                "lambda:*",
                "sns:*",
                "application-autoscaling:*",
                "s3:*",
                "logs:*",
                "cloudformation:*",
                "dynamodb:*",
                "cloud9:*",
                "elasticloadbalancing:*",
                "autoscaling:*",
                "iam:*",
                "cloudfront:*",
                "cloudwatch:*",
                "ecs:*",
                "ecr:*",
                "pricing:*",
                "ec2:*",
                "config:*",
                "elasticache:*"
            ],
            "Resource": "*"
        }
    ]
}
Click Review Policy.
For Name, type edXOptimizingPolicy
Click Create policy.
You have successfully created an IAM policy. When you create IAM policies, follow the standard security advice of granting least privilege - that is, granting only the permissions required to perform a task. Determine what users need to do and then craft policies for them that let the users perform only those tasks.

2. Create an IAM user and attach a policy to the user.
In this section, you will create an IAM user and attach the policy to the user. If you are familiar with IAM users, you may want to attempt to complete this section before reading the step-by-step instructions.

IAM user name: edXOptimizingUser
Access type: AWS Management Console access
Policy: edXOptimizingPolicy
Important Make a note of the password for the edXOptimizingUser and the sign-in URL for the IAM user. You should see the sign-in URL in the success message at the top.
Expand for step-by-step instructions.
In the AWS Management Console, click Services, then click IAM to open the IAM dashboard.
In the left navigation menu, click Users.
Click Add user.
In the User name text box, type edXOptimizingUser
For Access type, select AWS Management Console access.
For Console password, you may choose either Autogenerated password or Custom password. If you choose Autogenerated, you will be prompted to change your console password when you log in to the AWS Management Console as the edXOptimizingUser user. Make a note of the password.
Click Next: Permissions.
Under Set permissions for edXOptimizingUser, click Attach existing policies directly.
In the search text box for Filter, type edXOptimizingPolicy. Select edXOptimizingPolicy from the filtered list.
Click Next: Review.
Review the information and click Create user. You should see a success message.
Make sure to note the password for the edXOptimizingUser.
Note the sign-in URL in the success message at the top. This is a special URL for IAM users, which includes your account ID.
Sign out of the console, and sign back in as the edXOptimizingUser IAM user.
3. Create an AWS Cloud9 environment.
In this section, you will create an AWS Cloud9 environment and use it as a local development environment. If you are familiar with AWS Cloud9, you may want to attempt to complete this section before reading the step-by-step instructions.

AWS Cloud9 environment name: edXOptimizing
Network and Instance type settings: Keep the default settings.

Expand for step-by-step instructions.
4. Download and explore the application code.
Make sure you are in the home directory of your AWS Cloud9 environment by running the command below in the AWS Cloud9 terminal.
cd ~/environment

To download the application code, run the command below in your AWS Cloud9 terminal.
wget https://us-west-2-tcdev.s3.amazonaws.com/courses/AWS-100-ADO/v1.0.0/exercises/ex-ecs.zip -O ~/ex-ecs.zip

Unzip the application code by running the command below.
unzip -o ~/ex-ecs.zip

Expand the ex-ecs folder and observe that there are two sub-folders called ApplicationServer and FrontEnd. Expand the ApplicationServer folder and observe that it contains the application code, a Dockerfile, and a requirements.txt file. Open the Dockerfile. Observe that the Dockerfile contains commands to download the source code and to install the requirements when creating the container for the ApplicationServer component. The Expose command tells you the port on which the ApplicationServer container will run. Similarly, open the ex-ecs/FrontEnd/Dockerfile and explore the commands. Observe that the FrontEnd container will run on port 8080.
5. Create and test the containers.
In this section, you will create two containers for the ApplicationServer and the FrontEnd components of the application you downloaded in the previous section. Follow the steps below.

Change your working directory by running the command below.

cd ex-ecs/ApplicationServer/
Build the Docker container for the ApplicationServer by running the command below. The container is tagged as timezones-appserver. Note: the last parameter . is needed, this represents the current directory.
docker build -t timezones-appserver .

Run the command below to see the Docker images created. You should see the timezones-appserver container created on top of the Python layer.
docker images

Run the timezones-appserver container by running the command below. The command below runs the container in an interactive mode and maps port 8081 of the AWS Cloud9 instance to port 8081 of the container. You can read more about the Docker run command here.
docker run -it -p 8081:8081 timezones-appserver

You should see a message similar to below.
Running on http://0.0.0.0:8081/

To test the timezones-appserver container, you need to open a new terminal window in your AWS Cloud9 environment. Click the + sign next to your current terminal window tab and then click New Terminal to open a new terminal window.
You will also need the private IP address of the AWS Cloud9 instance to test the container. To get the private IP address of the AWS Cloud9 instance, open the EC2 dashboard.
In the left side navigation menu, click Instances.
Locate and select the instance for the edXOptimizing Cloud9 environment. The name of the instance will be similar to aws-cloud9-edXOptimizing-XXXX.
In the Description tab at the bottom, copy the private IP address of the instance and make a note of it.
Go back to your new AWS Cloud9 terminal.
To see the containers that are currently running, run the command below.
docker ps

You should see a message similar to below.
CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
47976b36c9e0        timezones-appserver   "python /src/applica"   About an hour ago   Up About an hour    0.0.0.0:8081->8081/tcp   stupefied_colden
This means that currently there is one container named timezones-appserver running and port 8081 of the local Cloud9 instance is mapped to port 8081 of the container.
Run the command below to test the timezones-appserver container. Replace REPLACE_WITH_PRIVATE_IP in the command below with the private IP address of the AWS Cloud9 instance you just copied. With this command, you are hitting an API called get_zones in timezones-appserver container.
curl http://REPLACE_WITH_PRIVATE_IP:8081/api/v1.0/get_zones

You should see a JSON response, as shown below.

  {
  "hostname": "47976b36c9e0",
  "zones": {
    "ap-northeast-1": {
      "TZ": "Asia/Tokyo",
      "Title": "Tokyo"
    },
    "ap-northeast-2": {
      "TZ": "Asia/Seoul",
      "Title": "Seoul"
    },
    "ap-south-1": {
      "TZ": "Asia/Kolkata",
      "Title": "Mumbai"
    },
    "ap-southeast-1": {
      "TZ": "Asia/Singapore",
      "Title": "Singapore"
    },
    "ap-southeast-2": {
      "TZ": "Australia/Sydney",
      "Title": "Sydney"
    },
    "ca-central-1": {
      "TZ": "Canada/Eastern",
      "Title": "Montreal"
    },
    "eu-central-1": {
      "TZ": "Europe/Berlin",
      "Title": "Frankfurt"
    },
    "eu-west-1": {
      "TZ": "Europe/Dublin",
      "Title": "Ireland"
    },
    "eu-west-2": {
      "TZ": "Europe/London",
      "Title": "London"
    },
    "eu-west-3": {
      "TZ": "Europe/Paris",
      "Title": "Paris"
    },
    "sa-east-1": {
      "TZ": "America/Sao_Paulo",
      "Title": "S\u00e3o Paulo"
    },
    "us-east-1": {
      "TZ": "US/Eastern",
      "Title": "N. Virginia"
    },
    "us-east-2": {
      "TZ": "US/Eastern",
      "Title": "Ohio"
    },
    "us-joke-1": {
      "TZ": "US/Mountain",
      "Title": "Roswell, NM"
    },
    "us-west-1": {
      "TZ": "US/Pacific",
      "Title": "N. California"
    },
    "us-west-2": {
      "TZ": "US/Pacific",
      "Title": "Oregon"
    }
  }
}
Change your working directory to create the second container for the FrontEnd component by running the command below. Important: Make sure to run the command below in the new AWS Cloud9 terminal you just opened. Do not run the command in the previous terminal where the timezones-appserver container is running.
cd ~/environment/ex-ecs/FrontEnd

Build the Docker container for the FrontEnd component by running the command below. The container is tagged as timezones-frontend.
docker build -t timezones-frontend .

To run the timezones-frontend container, run the command below. The timezones-frontend container needs the ApplicationServer URL for it to run successfully. You pass the ApplicationServer URL as a parameter by using the APP_SERVER variable as shown in the command below. Replace REPLACE_WITH_PRIVATE_IP in the command below with the private IP address of the Cloud9 instance.
docker run -it -e APP_SERVER=http://REPLACE_WITH_PRIVATE_IP:8081 -p 8080:8080 timezones-frontend

You should see a message similar to below.
Running on http://0.0.0.0:8080/

This means the timezones-frontend container is running on port 8080 of the container.
To test the timezones-frontend container, click Preview -> Preview Running Application on the top menu bar. You should see the application load in a small window at the bottom.
Pop out the application to a new browser window. Select a geographical location and observe that the application gives the current time in that location.
You have successfully containerized the components ApplicationServer and FrontEnd of the application.

Optional Challenge 1
To simplify the exercise we are using the Python Flask development server inside the docker container. This is not recommended for production. A sample Dockerfile has been supplied to run the application in a container using the Apache web server with a WSGI server. Run the commands below to overwrite your current Dockfiles, and add Apache web server settings. 

cd ~/environment
wget https://us-west-2-tcdev.s3.amazonaws.com/courses/AWS-100-ADO/v1.0.0/exercises/ex-ecs-apache.zip -O ~/ex-ecs-apache.zip
unzip -o ~/ex-ecs-apache.zip
Using the docker commands you have learned in this exercise attempt the following.

Create two new docker images from the updated Dockerfiles tagged as timezones-appserver-apache, and timezones-frontend-apache.
Run the two containers inside your Cloud9 environment, with the front end container configured to use the app server container.
When running the Apache web server in a container use the -d switch rather than -it to run the container detached. Apache web server will gracefully shut down when it receives a window size changed signal (see ASF Bugzilla - Bug 50669). This will cause the container to exit whenever a window is resized, e.g. when you use the Cloud9 preview.
